<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>brazilnortheastern_ecospace</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="BrazilNortheastern_ECOSPACE_files/libs/clipboard/clipboard.min.js"></script>
<script src="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/quarto.js"></script>
<script src="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/popper.min.js"></script>
<script src="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/anchor.min.js"></script>
<link href="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="BrazilNortheastern_ECOSPACE_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="BrazilNortheastern_ECOSPACE_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="BrazilNortheastern_ECOSPACE_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="BrazilNortheastern_ECOSPACE_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<p><strong>Model name</strong></p>
<p>Brazilian northeastern Ecospace Model</p>
<p><strong>Contacts</strong></p>
<p>Alex Lira (alexliraufrpe@outlook.com), Ronaldo Angelini (ronangelini@gmail.com), Leonardo Capitani (leocapi07@gmail.com)</p>
<p><strong>Spatial scale forcing</strong></p>
<p>Regional at 1.2 km2 grid resolution (515 lines * 250 columns, 17,290 grid cells, total ecosystem area modeled 31,105 km2 )</p>
<p><img src="images/brazilEcoModel.png" class="img-fluid"></p>
<p><strong>Levels of gear disaggregation</strong></p>
<p>4 fleets (Longline, bottom trawl, pots/traps, and seine nets)</p>
<p><strong>Levels of functional group disaggregation</strong></p>
<p>55 functional groups (36 fish species or groups, ten invertebrates, three mammals, one bird, one reptile, three primary producers, and one detritus)</p>
<p><strong>Spatial grid-cell allocation method</strong></p>
<p>Simple fishing effort gravity model based on cost/benefit analysis</p>
<p>JS to dig up formula</p>
<p><strong>Fishing mortality rate equation</strong></p>
<p>[How are fishing mortality and catch rates calculated in your model? Please provide equations as well as description]</p>
<p><strong>Selectivity (size,age,species)</strong></p>
<p>[If you have a selectivity term please describe it, with equation]</p>
<p><strong>Model calibration</strong></p>
<p>We calibrated the Ecosim model using the “Fit to Time Series” routine, using fishing</p>
<p>landings for 19 species (1987 – 2007) and primary productivity time series.</p>
<p><strong>Catchability and Creep (yearly rate of change catchability) Estimates</strong></p>
<p>[Please provide details on the specific estimated parameters from the calibration, e.g.&nbsp;range of creep of 2-5% per year; and catchability coefficients per gear / functional group as necessary]</p>
<p><strong>Further details on calibration</strong></p>
<p>Primary productivity was used to drive temporal variability of production of the phytoplankton compartment in the model. The fit was improved by automatically changing the vulnerability values for each interaction between a predator and prey, reducing the sum of squares between predicted and observed data.</p>
<p><strong>Statistical metrics</strong></p>
<p>[Please provide detail on the statistical method used in your calibration - E.g. optimisation, error terms]</p>
<p>N/A<br>
<strong>Statistical results (summary)</strong></p>
<p>[Please provide a summary of the metrics and results associated with your model calibration - E.g. RMSE with observed catches and any other process-based or theoretical criteria used to calibrate the model, comparison of modelled biomass, growth rates, P"B ratios etc]</p>
<p>N/A<br>
<strong>Model changes or&nbsp; improvements(s) made as a result of calibration</strong></p>
<p>Vulnerabilities values were increased for groups Hypanus spp, Other Zoobentivores</p>
<p>and Other Invertivores, and reduced for Caranx spp, Sharks and Other Piscivores. In</p>
<p>general, the vulnerability matrix maintains the original values (~2).</p>
<p><strong>ADDITIONAL DETAILS FOR REGIONAL MODELS ONLY:</strong></p>
<p><strong>Downscaling method</strong></p>
<p>We used several Brazilian official fisheries reports (e.g., IBAMA, 2007; IBGE, 1989) to reconstruct the historical fisheries catches in the area for the period 1987-2007. In addition, we used relative effort (kW x 1000) by fishing gear (longline, bottom trawl, pots/ traps, and seine nets) from the Sea Around Us (SAU) project for Brazil (Pauly and Zeller, 2015).</p>
<p>Although the categorization of fishing gears is commonly used to denote commercial fishing in the area, we adopted the same categorization for small-scale fisheries because they are common in capturing exploited species (Diegues, 2006).</p>
<p><strong>The "base" year range of the regional model</strong></p>
<p>1987 – 2007</p>
<p><br>
</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>